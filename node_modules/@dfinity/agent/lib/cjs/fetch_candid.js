"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCandid = void 0;
const _1 = require(".");
const principal_1 = require("@dfinity/principal");
/**
 * Retrieves the Candid interface for the specified canister.
 *
 * @param agent The agent to use for the request (usually an `HttpAgent`)
 * @param canisterId A string corresponding to the canister ID
 * @returns Candid source code
 */
async function fetchCandid(canisterId, agent) {
    if (!agent) {
        // Create an anonymous `HttpAgent` (adapted from Candid UI)
        agent = new _1.HttpAgent();
        if (agent.isLocal()) {
            agent.fetchRootKey();
        }
    }
    // Attempt to use canister metadata
    const status = await _1.CanisterStatus.request({
        agent,
        canisterId: principal_1.Principal.fromText(canisterId),
        paths: ['candid'],
    });
    const candid = status.get('candid');
    if (candid) {
        return candid;
    }
    // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata
    const tmpHackInterface = ({ IDL }) => IDL.Service({
        __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query']),
    });
    const actor = _1.Actor.createActor(tmpHackInterface, { agent, canisterId });
    return (await actor.__get_candid_interface_tmp_hack());
}
exports.fetchCandid = fetchCandid;
//# sourceMappingURL=fetch_candid.js.map